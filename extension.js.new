/**
 * Find an associated model based on relationship declarations
 * @param {string} rootPath - Project root path
 * @param {string} modelName - Source model name
 * @param {string} associationName - Association name to find
 * @returns {Promise<{filePath: string, line: number, associationType: string} | null>}
 */
async function findAssociatedModel(rootPath, modelName, associationName) {
    console.log(`Searching for association '${associationName}' from model '${modelName}'`);
    
    // First, find the model file
    const possibleNames = [
        modelName,
        modelName.toLowerCase(),
        inflectToSingular(modelName),
        inflectToPlural(modelName)
    ];
    
    let modelPath = null;
    let modelContent = null;
    
    // Try to find the model file
    for (const name of possibleNames) {
        const potentialPath = path.join(rootPath, 'app/models', `${name.toLowerCase()}.rb`);
        if (fs.existsSync(potentialPath)) {
            modelPath = potentialPath;
            modelContent = fs.readFileSync(potentialPath, 'utf8');
            break;
        }
    }
    
    if (!modelPath || !modelContent) {
        console.log(`Could not find model file for '${modelName}'`);
        return null;
    }
    
    // Define patterns for common association types
    const associationPatterns = [
        { type: 'belongs_to', pattern: `belongs_to\\s+:${associationName}\\b` },
        { type: 'has_many', pattern: `has_many\\s+:${associationName}\\b` },
        { type: 'has_one', pattern: `has_one\\s+:${associationName}\\b` },
        { type: 'has_and_belongs_to_many', pattern: `has_and_belongs_to_many\\s+:${associationName}\\b` }
    ];
    
    // Look for the association in the model file
    let associationType = null;
    let lineNumber = -1;
    
    for (const { type, pattern } of associationPatterns) {
        const regex = new RegExp(pattern, 'i');
        const match = modelContent.match(regex);
        
        if (match) {
            associationType = type;
            lineNumber = modelContent.substring(0, match.index).split('\n').length - 1;
            break;
        }
    }
    
    if (!associationType) {
        console.log(`No association '${associationName}' found in model '${modelName}'`);
        return null;
    }
    
    // Try to determine the target model class based on association type and Rails conventions
    let targetModelName = null;
    
    if (associationType === 'belongs_to') {
        // belongs_to uses singular form
        targetModelName = inflectToSingular(associationName);
        // If association is plural, Rails would singularize it internally
        targetModelName = targetModelName.charAt(0).toUpperCase() + targetModelName.slice(1);
    } else {
        // has_many, has_one, has_and_belongs_to_many use singular form of the target model
        targetModelName = inflectToSingular(associationName);
        // If association is plural, Rails would singularize it internally
        targetModelName = targetModelName.charAt(0).toUpperCase() + targetModelName.slice(1);
    }
    
    // Check for class_name option in the association
    const classNameMatch = modelContent.match(new RegExp(`${associationType}\\s+:${associationName}[^\\n]*class_name[^\\n]*["']([^"']+)["']`, 'i'));
    if (classNameMatch && classNameMatch[1]) {
        targetModelName = classNameMatch[1];
    }
    
    console.log(`Looking for target model: ${targetModelName}`);
    
    // Find the target model
    const targetModelMatch = await findModel(rootPath, targetModelName);
    if (targetModelMatch) {
        return {
            ...targetModelMatch,
            associationType
        };
    }
    
    return null;
}
